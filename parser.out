Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> Progarm
Rule 1     Progarm -> DeclareStr
Rule 2     DeclareStr -> Declare TDeclare
Rule 3     Declare -> INT ID DeclareFun
Rule 4     Declare -> INT ID DeclareType
Rule 5     Declare -> VOID ID DeclareFun
Rule 6     TDeclare -> empty
Rule 7     TDeclare -> Declare TDeclare
Rule 8     DeclareType -> ;
Rule 9     DeclareFun -> ( FormalPara ) Block
Rule 10    FormalPara -> ParaTable
Rule 11    FormalPara -> VOID
Rule 12    ParaTable -> Parameter TParaTable
Rule 13    TParaTable -> empty
Rule 14    TParaTable -> , Parameter TParaTable
Rule 15    Parameter -> INT ID
Rule 16    Block -> { LangStr TLangStr }
Rule 17    TLangStr -> empty
Rule 18    TLangStr -> LangStr TLangStr
Rule 19    LangStr -> InterDeclare
Rule 20    LangStr -> InterStr
Rule 21    InterDeclare -> InterVarDeclare ;
Rule 22    InterVarDeclare -> INT ID
Rule 23    InterStr -> Sentence
Rule 24    Sentence -> IfSentence
Rule 25    Sentence -> WhileSentence
Rule 26    Sentence -> ReturnSentence
Rule 27    Sentence -> AssignSentence
Rule 28    AssignSentence -> ID = Expression ;
Rule 29    ReturnSentence -> RETURN ;
Rule 30    ReturnSentence -> RETURN Expression ;
Rule 31    WhileSentence -> WHILE M ( Expression ) M Block
Rule 32    M -> empty
Rule 33    S -> empty
Rule 34    IfSentence -> IF ( Expression ) M Block N M ElseSentence
Rule 35    N -> empty
Rule 36    ElseSentence -> empty
Rule 37    ElseSentence -> ELSE Block
Rule 38    Expression -> AddExpression
Rule 39    Expression -> AddExpression < AddExpression
Rule 40    Expression -> AddExpression LESS AddExpression
Rule 41    Expression -> AddExpression > AddExpression
Rule 42    Expression -> AddExpression GREATER AddExpression
Rule 43    Expression -> AddExpression EQUAL AddExpression
Rule 44    Expression -> AddExpression UNEQUAL AddExpression
Rule 45    Expression -> - Expression
Rule 46    AddExpression -> Term
Rule 47    AddExpression -> Term + Term
Rule 48    AddExpression -> Term - Term
Rule 49    Term -> Factor
Rule 50    Term -> Factor * Factor
Rule 51    Term -> Factor / Factor
Rule 52    Factor -> NUMBER
Rule 53    Factor -> ( Expression )
Rule 54    Factor -> ID FTYPE
Rule 55    FTYPE -> Call
Rule 56    FTYPE -> empty
Rule 57    Call -> ( RealPara )
Rule 58    RealPara -> RealParaTable
Rule 59    RealPara -> empty
Rule 60    RealParaTable -> Para TRealParaTable
Rule 61    TRealParaTable -> , Para TRealParaTable
Rule 62    TRealParaTable -> empty
Rule 63    Para -> Expression
Rule 64    empty -> <empty>

Terminals, with rules where they appear

(                    : 9 31 34 53 57
)                    : 9 31 34 53 57
*                    : 50
+                    : 47
,                    : 14 61
-                    : 45 48
/                    : 51
;                    : 8 21 28 29 30
<                    : 39
=                    : 28
>                    : 41
ELSE                 : 37
EQUAL                : 43
GREATER              : 42
ID                   : 3 4 5 15 22 28 54
IF                   : 34
INT                  : 3 4 15 22
LESS                 : 40
NUMBER               : 52
RETURN               : 29 30
UNEQUAL              : 44
VOID                 : 5 11
WHILE                : 31
error                : 
{                    : 16
}                    : 16

Nonterminals, with rules where they appear

AddExpression        : 38 39 39 40 40 41 41 42 42 43 43 44 44
AssignSentence       : 27
Block                : 9 31 34 37
Call                 : 55
Declare              : 2 7
DeclareFun           : 3 5
DeclareStr           : 1
DeclareType          : 4
ElseSentence         : 34
Expression           : 28 30 31 34 45 53 63
FTYPE                : 54
Factor               : 49 50 50 51 51
FormalPara           : 9
IfSentence           : 24
InterDeclare         : 19
InterStr             : 20
InterVarDeclare      : 21
LangStr              : 16 18
M                    : 31 31 34 34
N                    : 34
Para                 : 60 61
ParaTable            : 10
Parameter            : 12 14
Progarm              : 0
RealPara             : 57
RealParaTable        : 58
ReturnSentence       : 26
S                    : 
Sentence             : 23
TDeclare             : 2 7
TLangStr             : 16 18
TParaTable           : 12 14
TRealParaTable       : 60 61
Term                 : 46 47 47 48 48
WhileSentence        : 25
empty                : 6 13 17 32 33 35 36 56 59 62

Parsing method: LALR

state 0

    (0) S' -> . Progarm
    (1) Progarm -> . DeclareStr
    (2) DeclareStr -> . Declare TDeclare
    (3) Declare -> . INT ID DeclareFun
    (4) Declare -> . INT ID DeclareType
    (5) Declare -> . VOID ID DeclareFun

    INT             shift and go to state 4
    VOID            shift and go to state 5

    Progarm                        shift and go to state 1
    DeclareStr                     shift and go to state 2
    Declare                        shift and go to state 3

state 1

    (0) S' -> Progarm .



state 2

    (1) Progarm -> DeclareStr .

    $end            reduce using rule 1 (Progarm -> DeclareStr .)


state 3

    (2) DeclareStr -> Declare . TDeclare
    (6) TDeclare -> . empty
    (7) TDeclare -> . Declare TDeclare
    (64) empty -> .
    (3) Declare -> . INT ID DeclareFun
    (4) Declare -> . INT ID DeclareType
    (5) Declare -> . VOID ID DeclareFun

    $end            reduce using rule 64 (empty -> .)
    INT             shift and go to state 4
    VOID            shift and go to state 5

    Declare                        shift and go to state 6
    TDeclare                       shift and go to state 7
    empty                          shift and go to state 8

state 4

    (3) Declare -> INT . ID DeclareFun
    (4) Declare -> INT . ID DeclareType

    ID              shift and go to state 9


state 5

    (5) Declare -> VOID . ID DeclareFun

    ID              shift and go to state 10


state 6

    (7) TDeclare -> Declare . TDeclare
    (6) TDeclare -> . empty
    (7) TDeclare -> . Declare TDeclare
    (64) empty -> .
    (3) Declare -> . INT ID DeclareFun
    (4) Declare -> . INT ID DeclareType
    (5) Declare -> . VOID ID DeclareFun

    $end            reduce using rule 64 (empty -> .)
    INT             shift and go to state 4
    VOID            shift and go to state 5

    Declare                        shift and go to state 6
    TDeclare                       shift and go to state 11
    empty                          shift and go to state 8

state 7

    (2) DeclareStr -> Declare TDeclare .

    $end            reduce using rule 2 (DeclareStr -> Declare TDeclare .)


state 8

    (6) TDeclare -> empty .

    $end            reduce using rule 6 (TDeclare -> empty .)


state 9

    (3) Declare -> INT ID . DeclareFun
    (4) Declare -> INT ID . DeclareType
    (9) DeclareFun -> . ( FormalPara ) Block
    (8) DeclareType -> . ;

    (               shift and go to state 14
    ;               shift and go to state 15

    DeclareFun                     shift and go to state 12
    DeclareType                    shift and go to state 13

state 10

    (5) Declare -> VOID ID . DeclareFun
    (9) DeclareFun -> . ( FormalPara ) Block

    (               shift and go to state 14

    DeclareFun                     shift and go to state 16

state 11

    (7) TDeclare -> Declare TDeclare .

    $end            reduce using rule 7 (TDeclare -> Declare TDeclare .)


state 12

    (3) Declare -> INT ID DeclareFun .

    INT             reduce using rule 3 (Declare -> INT ID DeclareFun .)
    VOID            reduce using rule 3 (Declare -> INT ID DeclareFun .)
    $end            reduce using rule 3 (Declare -> INT ID DeclareFun .)


state 13

    (4) Declare -> INT ID DeclareType .

    INT             reduce using rule 4 (Declare -> INT ID DeclareType .)
    VOID            reduce using rule 4 (Declare -> INT ID DeclareType .)
    $end            reduce using rule 4 (Declare -> INT ID DeclareType .)


state 14

    (9) DeclareFun -> ( . FormalPara ) Block
    (10) FormalPara -> . ParaTable
    (11) FormalPara -> . VOID
    (12) ParaTable -> . Parameter TParaTable
    (15) Parameter -> . INT ID

    VOID            shift and go to state 19
    INT             shift and go to state 21

    FormalPara                     shift and go to state 17
    ParaTable                      shift and go to state 18
    Parameter                      shift and go to state 20

state 15

    (8) DeclareType -> ; .

    INT             reduce using rule 8 (DeclareType -> ; .)
    VOID            reduce using rule 8 (DeclareType -> ; .)
    $end            reduce using rule 8 (DeclareType -> ; .)


state 16

    (5) Declare -> VOID ID DeclareFun .

    INT             reduce using rule 5 (Declare -> VOID ID DeclareFun .)
    VOID            reduce using rule 5 (Declare -> VOID ID DeclareFun .)
    $end            reduce using rule 5 (Declare -> VOID ID DeclareFun .)


state 17

    (9) DeclareFun -> ( FormalPara . ) Block

    )               shift and go to state 22


state 18

    (10) FormalPara -> ParaTable .

    )               reduce using rule 10 (FormalPara -> ParaTable .)


state 19

    (11) FormalPara -> VOID .

    )               reduce using rule 11 (FormalPara -> VOID .)


state 20

    (12) ParaTable -> Parameter . TParaTable
    (13) TParaTable -> . empty
    (14) TParaTable -> . , Parameter TParaTable
    (64) empty -> .

    ,               shift and go to state 25
    )               reduce using rule 64 (empty -> .)

    TParaTable                     shift and go to state 23
    empty                          shift and go to state 24

state 21

    (15) Parameter -> INT . ID

    ID              shift and go to state 26


state 22

    (9) DeclareFun -> ( FormalPara ) . Block
    (16) Block -> . { LangStr TLangStr }

    {               shift and go to state 28

    Block                          shift and go to state 27

state 23

    (12) ParaTable -> Parameter TParaTable .

    )               reduce using rule 12 (ParaTable -> Parameter TParaTable .)


state 24

    (13) TParaTable -> empty .

    )               reduce using rule 13 (TParaTable -> empty .)


state 25

    (14) TParaTable -> , . Parameter TParaTable
    (15) Parameter -> . INT ID

    INT             shift and go to state 21

    Parameter                      shift and go to state 29

state 26

    (15) Parameter -> INT ID .

    ,               reduce using rule 15 (Parameter -> INT ID .)
    )               reduce using rule 15 (Parameter -> INT ID .)


state 27

    (9) DeclareFun -> ( FormalPara ) Block .

    INT             reduce using rule 9 (DeclareFun -> ( FormalPara ) Block .)
    VOID            reduce using rule 9 (DeclareFun -> ( FormalPara ) Block .)
    $end            reduce using rule 9 (DeclareFun -> ( FormalPara ) Block .)


state 28

    (16) Block -> { . LangStr TLangStr }
    (19) LangStr -> . InterDeclare
    (20) LangStr -> . InterStr
    (21) InterDeclare -> . InterVarDeclare ;
    (23) InterStr -> . Sentence
    (22) InterVarDeclare -> . INT ID
    (24) Sentence -> . IfSentence
    (25) Sentence -> . WhileSentence
    (26) Sentence -> . ReturnSentence
    (27) Sentence -> . AssignSentence
    (34) IfSentence -> . IF ( Expression ) M Block N M ElseSentence
    (31) WhileSentence -> . WHILE M ( Expression ) M Block
    (29) ReturnSentence -> . RETURN ;
    (30) ReturnSentence -> . RETURN Expression ;
    (28) AssignSentence -> . ID = Expression ;

    INT             shift and go to state 35
    IF              shift and go to state 41
    WHILE           shift and go to state 42
    RETURN          shift and go to state 43
    ID              shift and go to state 36

    LangStr                        shift and go to state 30
    InterDeclare                   shift and go to state 31
    InterStr                       shift and go to state 32
    InterVarDeclare                shift and go to state 33
    Sentence                       shift and go to state 34
    IfSentence                     shift and go to state 37
    WhileSentence                  shift and go to state 38
    ReturnSentence                 shift and go to state 39
    AssignSentence                 shift and go to state 40

state 29

    (14) TParaTable -> , Parameter . TParaTable
    (13) TParaTable -> . empty
    (14) TParaTable -> . , Parameter TParaTable
    (64) empty -> .

    ,               shift and go to state 25
    )               reduce using rule 64 (empty -> .)

    TParaTable                     shift and go to state 44
    empty                          shift and go to state 24

state 30

    (16) Block -> { LangStr . TLangStr }
    (17) TLangStr -> . empty
    (18) TLangStr -> . LangStr TLangStr
    (64) empty -> .
    (19) LangStr -> . InterDeclare
    (20) LangStr -> . InterStr
    (21) InterDeclare -> . InterVarDeclare ;
    (23) InterStr -> . Sentence
    (22) InterVarDeclare -> . INT ID
    (24) Sentence -> . IfSentence
    (25) Sentence -> . WhileSentence
    (26) Sentence -> . ReturnSentence
    (27) Sentence -> . AssignSentence
    (34) IfSentence -> . IF ( Expression ) M Block N M ElseSentence
    (31) WhileSentence -> . WHILE M ( Expression ) M Block
    (29) ReturnSentence -> . RETURN ;
    (30) ReturnSentence -> . RETURN Expression ;
    (28) AssignSentence -> . ID = Expression ;

    }               reduce using rule 64 (empty -> .)
    INT             shift and go to state 35
    IF              shift and go to state 41
    WHILE           shift and go to state 42
    RETURN          shift and go to state 43
    ID              shift and go to state 36

    LangStr                        shift and go to state 45
    TLangStr                       shift and go to state 46
    empty                          shift and go to state 47
    InterDeclare                   shift and go to state 31
    InterStr                       shift and go to state 32
    InterVarDeclare                shift and go to state 33
    Sentence                       shift and go to state 34
    IfSentence                     shift and go to state 37
    WhileSentence                  shift and go to state 38
    ReturnSentence                 shift and go to state 39
    AssignSentence                 shift and go to state 40

state 31

    (19) LangStr -> InterDeclare .

    INT             reduce using rule 19 (LangStr -> InterDeclare .)
    IF              reduce using rule 19 (LangStr -> InterDeclare .)
    WHILE           reduce using rule 19 (LangStr -> InterDeclare .)
    RETURN          reduce using rule 19 (LangStr -> InterDeclare .)
    ID              reduce using rule 19 (LangStr -> InterDeclare .)
    }               reduce using rule 19 (LangStr -> InterDeclare .)


state 32

    (20) LangStr -> InterStr .

    INT             reduce using rule 20 (LangStr -> InterStr .)
    IF              reduce using rule 20 (LangStr -> InterStr .)
    WHILE           reduce using rule 20 (LangStr -> InterStr .)
    RETURN          reduce using rule 20 (LangStr -> InterStr .)
    ID              reduce using rule 20 (LangStr -> InterStr .)
    }               reduce using rule 20 (LangStr -> InterStr .)


state 33

    (21) InterDeclare -> InterVarDeclare . ;

    ;               shift and go to state 48


state 34

    (23) InterStr -> Sentence .

    INT             reduce using rule 23 (InterStr -> Sentence .)
    IF              reduce using rule 23 (InterStr -> Sentence .)
    WHILE           reduce using rule 23 (InterStr -> Sentence .)
    RETURN          reduce using rule 23 (InterStr -> Sentence .)
    ID              reduce using rule 23 (InterStr -> Sentence .)
    }               reduce using rule 23 (InterStr -> Sentence .)


state 35

    (22) InterVarDeclare -> INT . ID

    ID              shift and go to state 49


state 36

    (28) AssignSentence -> ID . = Expression ;

    =               shift and go to state 50


state 37

    (24) Sentence -> IfSentence .

    INT             reduce using rule 24 (Sentence -> IfSentence .)
    IF              reduce using rule 24 (Sentence -> IfSentence .)
    WHILE           reduce using rule 24 (Sentence -> IfSentence .)
    RETURN          reduce using rule 24 (Sentence -> IfSentence .)
    ID              reduce using rule 24 (Sentence -> IfSentence .)
    }               reduce using rule 24 (Sentence -> IfSentence .)


state 38

    (25) Sentence -> WhileSentence .

    INT             reduce using rule 25 (Sentence -> WhileSentence .)
    IF              reduce using rule 25 (Sentence -> WhileSentence .)
    WHILE           reduce using rule 25 (Sentence -> WhileSentence .)
    RETURN          reduce using rule 25 (Sentence -> WhileSentence .)
    ID              reduce using rule 25 (Sentence -> WhileSentence .)
    }               reduce using rule 25 (Sentence -> WhileSentence .)


state 39

    (26) Sentence -> ReturnSentence .

    INT             reduce using rule 26 (Sentence -> ReturnSentence .)
    IF              reduce using rule 26 (Sentence -> ReturnSentence .)
    WHILE           reduce using rule 26 (Sentence -> ReturnSentence .)
    RETURN          reduce using rule 26 (Sentence -> ReturnSentence .)
    ID              reduce using rule 26 (Sentence -> ReturnSentence .)
    }               reduce using rule 26 (Sentence -> ReturnSentence .)


state 40

    (27) Sentence -> AssignSentence .

    INT             reduce using rule 27 (Sentence -> AssignSentence .)
    IF              reduce using rule 27 (Sentence -> AssignSentence .)
    WHILE           reduce using rule 27 (Sentence -> AssignSentence .)
    RETURN          reduce using rule 27 (Sentence -> AssignSentence .)
    ID              reduce using rule 27 (Sentence -> AssignSentence .)
    }               reduce using rule 27 (Sentence -> AssignSentence .)


state 41

    (34) IfSentence -> IF . ( Expression ) M Block N M ElseSentence

    (               shift and go to state 51


state 42

    (31) WhileSentence -> WHILE . M ( Expression ) M Block
    (32) M -> . empty
    (64) empty -> .

    (               reduce using rule 64 (empty -> .)

    M                              shift and go to state 52
    empty                          shift and go to state 53

state 43

    (29) ReturnSentence -> RETURN . ;
    (30) ReturnSentence -> RETURN . Expression ;
    (38) Expression -> . AddExpression
    (39) Expression -> . AddExpression < AddExpression
    (40) Expression -> . AddExpression LESS AddExpression
    (41) Expression -> . AddExpression > AddExpression
    (42) Expression -> . AddExpression GREATER AddExpression
    (43) Expression -> . AddExpression EQUAL AddExpression
    (44) Expression -> . AddExpression UNEQUAL AddExpression
    (45) Expression -> . - Expression
    (46) AddExpression -> . Term
    (47) AddExpression -> . Term + Term
    (48) AddExpression -> . Term - Term
    (49) Term -> . Factor
    (50) Term -> . Factor * Factor
    (51) Term -> . Factor / Factor
    (52) Factor -> . NUMBER
    (53) Factor -> . ( Expression )
    (54) Factor -> . ID FTYPE

    ;               shift and go to state 54
    -               shift and go to state 57
    NUMBER          shift and go to state 60
    (               shift and go to state 61
    ID              shift and go to state 62

    Expression                     shift and go to state 55
    AddExpression                  shift and go to state 56
    Term                           shift and go to state 58
    Factor                         shift and go to state 59

state 44

    (14) TParaTable -> , Parameter TParaTable .

    )               reduce using rule 14 (TParaTable -> , Parameter TParaTable .)


state 45

    (18) TLangStr -> LangStr . TLangStr
    (17) TLangStr -> . empty
    (18) TLangStr -> . LangStr TLangStr
    (64) empty -> .
    (19) LangStr -> . InterDeclare
    (20) LangStr -> . InterStr
    (21) InterDeclare -> . InterVarDeclare ;
    (23) InterStr -> . Sentence
    (22) InterVarDeclare -> . INT ID
    (24) Sentence -> . IfSentence
    (25) Sentence -> . WhileSentence
    (26) Sentence -> . ReturnSentence
    (27) Sentence -> . AssignSentence
    (34) IfSentence -> . IF ( Expression ) M Block N M ElseSentence
    (31) WhileSentence -> . WHILE M ( Expression ) M Block
    (29) ReturnSentence -> . RETURN ;
    (30) ReturnSentence -> . RETURN Expression ;
    (28) AssignSentence -> . ID = Expression ;

    }               reduce using rule 64 (empty -> .)
    INT             shift and go to state 35
    IF              shift and go to state 41
    WHILE           shift and go to state 42
    RETURN          shift and go to state 43
    ID              shift and go to state 36

    LangStr                        shift and go to state 45
    TLangStr                       shift and go to state 63
    empty                          shift and go to state 47
    InterDeclare                   shift and go to state 31
    InterStr                       shift and go to state 32
    InterVarDeclare                shift and go to state 33
    Sentence                       shift and go to state 34
    IfSentence                     shift and go to state 37
    WhileSentence                  shift and go to state 38
    ReturnSentence                 shift and go to state 39
    AssignSentence                 shift and go to state 40

state 46

    (16) Block -> { LangStr TLangStr . }

    }               shift and go to state 64


state 47

    (17) TLangStr -> empty .

    }               reduce using rule 17 (TLangStr -> empty .)


state 48

    (21) InterDeclare -> InterVarDeclare ; .

    INT             reduce using rule 21 (InterDeclare -> InterVarDeclare ; .)
    IF              reduce using rule 21 (InterDeclare -> InterVarDeclare ; .)
    WHILE           reduce using rule 21 (InterDeclare -> InterVarDeclare ; .)
    RETURN          reduce using rule 21 (InterDeclare -> InterVarDeclare ; .)
    ID              reduce using rule 21 (InterDeclare -> InterVarDeclare ; .)
    }               reduce using rule 21 (InterDeclare -> InterVarDeclare ; .)


state 49

    (22) InterVarDeclare -> INT ID .

    ;               reduce using rule 22 (InterVarDeclare -> INT ID .)


state 50

    (28) AssignSentence -> ID = . Expression ;
    (38) Expression -> . AddExpression
    (39) Expression -> . AddExpression < AddExpression
    (40) Expression -> . AddExpression LESS AddExpression
    (41) Expression -> . AddExpression > AddExpression
    (42) Expression -> . AddExpression GREATER AddExpression
    (43) Expression -> . AddExpression EQUAL AddExpression
    (44) Expression -> . AddExpression UNEQUAL AddExpression
    (45) Expression -> . - Expression
    (46) AddExpression -> . Term
    (47) AddExpression -> . Term + Term
    (48) AddExpression -> . Term - Term
    (49) Term -> . Factor
    (50) Term -> . Factor * Factor
    (51) Term -> . Factor / Factor
    (52) Factor -> . NUMBER
    (53) Factor -> . ( Expression )
    (54) Factor -> . ID FTYPE

    -               shift and go to state 57
    NUMBER          shift and go to state 60
    (               shift and go to state 61
    ID              shift and go to state 62

    Expression                     shift and go to state 65
    AddExpression                  shift and go to state 56
    Term                           shift and go to state 58
    Factor                         shift and go to state 59

state 51

    (34) IfSentence -> IF ( . Expression ) M Block N M ElseSentence
    (38) Expression -> . AddExpression
    (39) Expression -> . AddExpression < AddExpression
    (40) Expression -> . AddExpression LESS AddExpression
    (41) Expression -> . AddExpression > AddExpression
    (42) Expression -> . AddExpression GREATER AddExpression
    (43) Expression -> . AddExpression EQUAL AddExpression
    (44) Expression -> . AddExpression UNEQUAL AddExpression
    (45) Expression -> . - Expression
    (46) AddExpression -> . Term
    (47) AddExpression -> . Term + Term
    (48) AddExpression -> . Term - Term
    (49) Term -> . Factor
    (50) Term -> . Factor * Factor
    (51) Term -> . Factor / Factor
    (52) Factor -> . NUMBER
    (53) Factor -> . ( Expression )
    (54) Factor -> . ID FTYPE

    -               shift and go to state 57
    NUMBER          shift and go to state 60
    (               shift and go to state 61
    ID              shift and go to state 62

    Expression                     shift and go to state 66
    AddExpression                  shift and go to state 56
    Term                           shift and go to state 58
    Factor                         shift and go to state 59

state 52

    (31) WhileSentence -> WHILE M . ( Expression ) M Block

    (               shift and go to state 67


state 53

    (32) M -> empty .

    (               reduce using rule 32 (M -> empty .)
    {               reduce using rule 32 (M -> empty .)
    ELSE            reduce using rule 32 (M -> empty .)
    INT             reduce using rule 32 (M -> empty .)
    IF              reduce using rule 32 (M -> empty .)
    WHILE           reduce using rule 32 (M -> empty .)
    RETURN          reduce using rule 32 (M -> empty .)
    ID              reduce using rule 32 (M -> empty .)
    }               reduce using rule 32 (M -> empty .)


state 54

    (29) ReturnSentence -> RETURN ; .

    INT             reduce using rule 29 (ReturnSentence -> RETURN ; .)
    IF              reduce using rule 29 (ReturnSentence -> RETURN ; .)
    WHILE           reduce using rule 29 (ReturnSentence -> RETURN ; .)
    RETURN          reduce using rule 29 (ReturnSentence -> RETURN ; .)
    ID              reduce using rule 29 (ReturnSentence -> RETURN ; .)
    }               reduce using rule 29 (ReturnSentence -> RETURN ; .)


state 55

    (30) ReturnSentence -> RETURN Expression . ;

    ;               shift and go to state 68


state 56

    (38) Expression -> AddExpression .
    (39) Expression -> AddExpression . < AddExpression
    (40) Expression -> AddExpression . LESS AddExpression
    (41) Expression -> AddExpression . > AddExpression
    (42) Expression -> AddExpression . GREATER AddExpression
    (43) Expression -> AddExpression . EQUAL AddExpression
    (44) Expression -> AddExpression . UNEQUAL AddExpression

    ;               reduce using rule 38 (Expression -> AddExpression .)
    )               reduce using rule 38 (Expression -> AddExpression .)
    ,               reduce using rule 38 (Expression -> AddExpression .)
    <               shift and go to state 69
    LESS            shift and go to state 70
    >               shift and go to state 71
    GREATER         shift and go to state 72
    EQUAL           shift and go to state 73
    UNEQUAL         shift and go to state 74


state 57

    (45) Expression -> - . Expression
    (38) Expression -> . AddExpression
    (39) Expression -> . AddExpression < AddExpression
    (40) Expression -> . AddExpression LESS AddExpression
    (41) Expression -> . AddExpression > AddExpression
    (42) Expression -> . AddExpression GREATER AddExpression
    (43) Expression -> . AddExpression EQUAL AddExpression
    (44) Expression -> . AddExpression UNEQUAL AddExpression
    (45) Expression -> . - Expression
    (46) AddExpression -> . Term
    (47) AddExpression -> . Term + Term
    (48) AddExpression -> . Term - Term
    (49) Term -> . Factor
    (50) Term -> . Factor * Factor
    (51) Term -> . Factor / Factor
    (52) Factor -> . NUMBER
    (53) Factor -> . ( Expression )
    (54) Factor -> . ID FTYPE

    -               shift and go to state 57
    NUMBER          shift and go to state 60
    (               shift and go to state 61
    ID              shift and go to state 62

    Expression                     shift and go to state 75
    AddExpression                  shift and go to state 56
    Term                           shift and go to state 58
    Factor                         shift and go to state 59

state 58

    (46) AddExpression -> Term .
    (47) AddExpression -> Term . + Term
    (48) AddExpression -> Term . - Term

    <               reduce using rule 46 (AddExpression -> Term .)
    LESS            reduce using rule 46 (AddExpression -> Term .)
    >               reduce using rule 46 (AddExpression -> Term .)
    GREATER         reduce using rule 46 (AddExpression -> Term .)
    EQUAL           reduce using rule 46 (AddExpression -> Term .)
    UNEQUAL         reduce using rule 46 (AddExpression -> Term .)
    ;               reduce using rule 46 (AddExpression -> Term .)
    )               reduce using rule 46 (AddExpression -> Term .)
    ,               reduce using rule 46 (AddExpression -> Term .)
    +               shift and go to state 76
    -               shift and go to state 77


state 59

    (49) Term -> Factor .
    (50) Term -> Factor . * Factor
    (51) Term -> Factor . / Factor

    +               reduce using rule 49 (Term -> Factor .)
    -               reduce using rule 49 (Term -> Factor .)
    <               reduce using rule 49 (Term -> Factor .)
    LESS            reduce using rule 49 (Term -> Factor .)
    >               reduce using rule 49 (Term -> Factor .)
    GREATER         reduce using rule 49 (Term -> Factor .)
    EQUAL           reduce using rule 49 (Term -> Factor .)
    UNEQUAL         reduce using rule 49 (Term -> Factor .)
    ;               reduce using rule 49 (Term -> Factor .)
    )               reduce using rule 49 (Term -> Factor .)
    ,               reduce using rule 49 (Term -> Factor .)
    *               shift and go to state 78
    /               shift and go to state 79


state 60

    (52) Factor -> NUMBER .

    *               reduce using rule 52 (Factor -> NUMBER .)
    /               reduce using rule 52 (Factor -> NUMBER .)
    +               reduce using rule 52 (Factor -> NUMBER .)
    -               reduce using rule 52 (Factor -> NUMBER .)
    <               reduce using rule 52 (Factor -> NUMBER .)
    LESS            reduce using rule 52 (Factor -> NUMBER .)
    >               reduce using rule 52 (Factor -> NUMBER .)
    GREATER         reduce using rule 52 (Factor -> NUMBER .)
    EQUAL           reduce using rule 52 (Factor -> NUMBER .)
    UNEQUAL         reduce using rule 52 (Factor -> NUMBER .)
    ;               reduce using rule 52 (Factor -> NUMBER .)
    )               reduce using rule 52 (Factor -> NUMBER .)
    ,               reduce using rule 52 (Factor -> NUMBER .)


state 61

    (53) Factor -> ( . Expression )
    (38) Expression -> . AddExpression
    (39) Expression -> . AddExpression < AddExpression
    (40) Expression -> . AddExpression LESS AddExpression
    (41) Expression -> . AddExpression > AddExpression
    (42) Expression -> . AddExpression GREATER AddExpression
    (43) Expression -> . AddExpression EQUAL AddExpression
    (44) Expression -> . AddExpression UNEQUAL AddExpression
    (45) Expression -> . - Expression
    (46) AddExpression -> . Term
    (47) AddExpression -> . Term + Term
    (48) AddExpression -> . Term - Term
    (49) Term -> . Factor
    (50) Term -> . Factor * Factor
    (51) Term -> . Factor / Factor
    (52) Factor -> . NUMBER
    (53) Factor -> . ( Expression )
    (54) Factor -> . ID FTYPE

    -               shift and go to state 57
    NUMBER          shift and go to state 60
    (               shift and go to state 61
    ID              shift and go to state 62

    Expression                     shift and go to state 80
    AddExpression                  shift and go to state 56
    Term                           shift and go to state 58
    Factor                         shift and go to state 59

state 62

    (54) Factor -> ID . FTYPE
    (55) FTYPE -> . Call
    (56) FTYPE -> . empty
    (57) Call -> . ( RealPara )
    (64) empty -> .

    (               shift and go to state 84
    *               reduce using rule 64 (empty -> .)
    /               reduce using rule 64 (empty -> .)
    +               reduce using rule 64 (empty -> .)
    -               reduce using rule 64 (empty -> .)
    <               reduce using rule 64 (empty -> .)
    LESS            reduce using rule 64 (empty -> .)
    >               reduce using rule 64 (empty -> .)
    GREATER         reduce using rule 64 (empty -> .)
    EQUAL           reduce using rule 64 (empty -> .)
    UNEQUAL         reduce using rule 64 (empty -> .)
    ;               reduce using rule 64 (empty -> .)
    )               reduce using rule 64 (empty -> .)
    ,               reduce using rule 64 (empty -> .)

    FTYPE                          shift and go to state 81
    Call                           shift and go to state 82
    empty                          shift and go to state 83

state 63

    (18) TLangStr -> LangStr TLangStr .

    }               reduce using rule 18 (TLangStr -> LangStr TLangStr .)


state 64

    (16) Block -> { LangStr TLangStr } .

    INT             reduce using rule 16 (Block -> { LangStr TLangStr } .)
    VOID            reduce using rule 16 (Block -> { LangStr TLangStr } .)
    $end            reduce using rule 16 (Block -> { LangStr TLangStr } .)
    ELSE            reduce using rule 16 (Block -> { LangStr TLangStr } .)
    IF              reduce using rule 16 (Block -> { LangStr TLangStr } .)
    WHILE           reduce using rule 16 (Block -> { LangStr TLangStr } .)
    RETURN          reduce using rule 16 (Block -> { LangStr TLangStr } .)
    ID              reduce using rule 16 (Block -> { LangStr TLangStr } .)
    }               reduce using rule 16 (Block -> { LangStr TLangStr } .)


state 65

    (28) AssignSentence -> ID = Expression . ;

    ;               shift and go to state 85


state 66

    (34) IfSentence -> IF ( Expression . ) M Block N M ElseSentence

    )               shift and go to state 86


state 67

    (31) WhileSentence -> WHILE M ( . Expression ) M Block
    (38) Expression -> . AddExpression
    (39) Expression -> . AddExpression < AddExpression
    (40) Expression -> . AddExpression LESS AddExpression
    (41) Expression -> . AddExpression > AddExpression
    (42) Expression -> . AddExpression GREATER AddExpression
    (43) Expression -> . AddExpression EQUAL AddExpression
    (44) Expression -> . AddExpression UNEQUAL AddExpression
    (45) Expression -> . - Expression
    (46) AddExpression -> . Term
    (47) AddExpression -> . Term + Term
    (48) AddExpression -> . Term - Term
    (49) Term -> . Factor
    (50) Term -> . Factor * Factor
    (51) Term -> . Factor / Factor
    (52) Factor -> . NUMBER
    (53) Factor -> . ( Expression )
    (54) Factor -> . ID FTYPE

    -               shift and go to state 57
    NUMBER          shift and go to state 60
    (               shift and go to state 61
    ID              shift and go to state 62

    Expression                     shift and go to state 87
    AddExpression                  shift and go to state 56
    Term                           shift and go to state 58
    Factor                         shift and go to state 59

state 68

    (30) ReturnSentence -> RETURN Expression ; .

    INT             reduce using rule 30 (ReturnSentence -> RETURN Expression ; .)
    IF              reduce using rule 30 (ReturnSentence -> RETURN Expression ; .)
    WHILE           reduce using rule 30 (ReturnSentence -> RETURN Expression ; .)
    RETURN          reduce using rule 30 (ReturnSentence -> RETURN Expression ; .)
    ID              reduce using rule 30 (ReturnSentence -> RETURN Expression ; .)
    }               reduce using rule 30 (ReturnSentence -> RETURN Expression ; .)


state 69

    (39) Expression -> AddExpression < . AddExpression
    (46) AddExpression -> . Term
    (47) AddExpression -> . Term + Term
    (48) AddExpression -> . Term - Term
    (49) Term -> . Factor
    (50) Term -> . Factor * Factor
    (51) Term -> . Factor / Factor
    (52) Factor -> . NUMBER
    (53) Factor -> . ( Expression )
    (54) Factor -> . ID FTYPE

    NUMBER          shift and go to state 60
    (               shift and go to state 61
    ID              shift and go to state 62

    AddExpression                  shift and go to state 88
    Term                           shift and go to state 58
    Factor                         shift and go to state 59

state 70

    (40) Expression -> AddExpression LESS . AddExpression
    (46) AddExpression -> . Term
    (47) AddExpression -> . Term + Term
    (48) AddExpression -> . Term - Term
    (49) Term -> . Factor
    (50) Term -> . Factor * Factor
    (51) Term -> . Factor / Factor
    (52) Factor -> . NUMBER
    (53) Factor -> . ( Expression )
    (54) Factor -> . ID FTYPE

    NUMBER          shift and go to state 60
    (               shift and go to state 61
    ID              shift and go to state 62

    AddExpression                  shift and go to state 89
    Term                           shift and go to state 58
    Factor                         shift and go to state 59

state 71

    (41) Expression -> AddExpression > . AddExpression
    (46) AddExpression -> . Term
    (47) AddExpression -> . Term + Term
    (48) AddExpression -> . Term - Term
    (49) Term -> . Factor
    (50) Term -> . Factor * Factor
    (51) Term -> . Factor / Factor
    (52) Factor -> . NUMBER
    (53) Factor -> . ( Expression )
    (54) Factor -> . ID FTYPE

    NUMBER          shift and go to state 60
    (               shift and go to state 61
    ID              shift and go to state 62

    AddExpression                  shift and go to state 90
    Term                           shift and go to state 58
    Factor                         shift and go to state 59

state 72

    (42) Expression -> AddExpression GREATER . AddExpression
    (46) AddExpression -> . Term
    (47) AddExpression -> . Term + Term
    (48) AddExpression -> . Term - Term
    (49) Term -> . Factor
    (50) Term -> . Factor * Factor
    (51) Term -> . Factor / Factor
    (52) Factor -> . NUMBER
    (53) Factor -> . ( Expression )
    (54) Factor -> . ID FTYPE

    NUMBER          shift and go to state 60
    (               shift and go to state 61
    ID              shift and go to state 62

    AddExpression                  shift and go to state 91
    Term                           shift and go to state 58
    Factor                         shift and go to state 59

state 73

    (43) Expression -> AddExpression EQUAL . AddExpression
    (46) AddExpression -> . Term
    (47) AddExpression -> . Term + Term
    (48) AddExpression -> . Term - Term
    (49) Term -> . Factor
    (50) Term -> . Factor * Factor
    (51) Term -> . Factor / Factor
    (52) Factor -> . NUMBER
    (53) Factor -> . ( Expression )
    (54) Factor -> . ID FTYPE

    NUMBER          shift and go to state 60
    (               shift and go to state 61
    ID              shift and go to state 62

    AddExpression                  shift and go to state 92
    Term                           shift and go to state 58
    Factor                         shift and go to state 59

state 74

    (44) Expression -> AddExpression UNEQUAL . AddExpression
    (46) AddExpression -> . Term
    (47) AddExpression -> . Term + Term
    (48) AddExpression -> . Term - Term
    (49) Term -> . Factor
    (50) Term -> . Factor * Factor
    (51) Term -> . Factor / Factor
    (52) Factor -> . NUMBER
    (53) Factor -> . ( Expression )
    (54) Factor -> . ID FTYPE

    NUMBER          shift and go to state 60
    (               shift and go to state 61
    ID              shift and go to state 62

    AddExpression                  shift and go to state 93
    Term                           shift and go to state 58
    Factor                         shift and go to state 59

state 75

    (45) Expression -> - Expression .

    ;               reduce using rule 45 (Expression -> - Expression .)
    )               reduce using rule 45 (Expression -> - Expression .)
    ,               reduce using rule 45 (Expression -> - Expression .)


state 76

    (47) AddExpression -> Term + . Term
    (49) Term -> . Factor
    (50) Term -> . Factor * Factor
    (51) Term -> . Factor / Factor
    (52) Factor -> . NUMBER
    (53) Factor -> . ( Expression )
    (54) Factor -> . ID FTYPE

    NUMBER          shift and go to state 60
    (               shift and go to state 61
    ID              shift and go to state 62

    Term                           shift and go to state 94
    Factor                         shift and go to state 59

state 77

    (48) AddExpression -> Term - . Term
    (49) Term -> . Factor
    (50) Term -> . Factor * Factor
    (51) Term -> . Factor / Factor
    (52) Factor -> . NUMBER
    (53) Factor -> . ( Expression )
    (54) Factor -> . ID FTYPE

    NUMBER          shift and go to state 60
    (               shift and go to state 61
    ID              shift and go to state 62

    Term                           shift and go to state 95
    Factor                         shift and go to state 59

state 78

    (50) Term -> Factor * . Factor
    (52) Factor -> . NUMBER
    (53) Factor -> . ( Expression )
    (54) Factor -> . ID FTYPE

    NUMBER          shift and go to state 60
    (               shift and go to state 61
    ID              shift and go to state 62

    Factor                         shift and go to state 96

state 79

    (51) Term -> Factor / . Factor
    (52) Factor -> . NUMBER
    (53) Factor -> . ( Expression )
    (54) Factor -> . ID FTYPE

    NUMBER          shift and go to state 60
    (               shift and go to state 61
    ID              shift and go to state 62

    Factor                         shift and go to state 97

state 80

    (53) Factor -> ( Expression . )

    )               shift and go to state 98


state 81

    (54) Factor -> ID FTYPE .

    *               reduce using rule 54 (Factor -> ID FTYPE .)
    /               reduce using rule 54 (Factor -> ID FTYPE .)
    +               reduce using rule 54 (Factor -> ID FTYPE .)
    -               reduce using rule 54 (Factor -> ID FTYPE .)
    <               reduce using rule 54 (Factor -> ID FTYPE .)
    LESS            reduce using rule 54 (Factor -> ID FTYPE .)
    >               reduce using rule 54 (Factor -> ID FTYPE .)
    GREATER         reduce using rule 54 (Factor -> ID FTYPE .)
    EQUAL           reduce using rule 54 (Factor -> ID FTYPE .)
    UNEQUAL         reduce using rule 54 (Factor -> ID FTYPE .)
    ;               reduce using rule 54 (Factor -> ID FTYPE .)
    )               reduce using rule 54 (Factor -> ID FTYPE .)
    ,               reduce using rule 54 (Factor -> ID FTYPE .)


state 82

    (55) FTYPE -> Call .

    *               reduce using rule 55 (FTYPE -> Call .)
    /               reduce using rule 55 (FTYPE -> Call .)
    +               reduce using rule 55 (FTYPE -> Call .)
    -               reduce using rule 55 (FTYPE -> Call .)
    <               reduce using rule 55 (FTYPE -> Call .)
    LESS            reduce using rule 55 (FTYPE -> Call .)
    >               reduce using rule 55 (FTYPE -> Call .)
    GREATER         reduce using rule 55 (FTYPE -> Call .)
    EQUAL           reduce using rule 55 (FTYPE -> Call .)
    UNEQUAL         reduce using rule 55 (FTYPE -> Call .)
    ;               reduce using rule 55 (FTYPE -> Call .)
    )               reduce using rule 55 (FTYPE -> Call .)
    ,               reduce using rule 55 (FTYPE -> Call .)


state 83

    (56) FTYPE -> empty .

    *               reduce using rule 56 (FTYPE -> empty .)
    /               reduce using rule 56 (FTYPE -> empty .)
    +               reduce using rule 56 (FTYPE -> empty .)
    -               reduce using rule 56 (FTYPE -> empty .)
    <               reduce using rule 56 (FTYPE -> empty .)
    LESS            reduce using rule 56 (FTYPE -> empty .)
    >               reduce using rule 56 (FTYPE -> empty .)
    GREATER         reduce using rule 56 (FTYPE -> empty .)
    EQUAL           reduce using rule 56 (FTYPE -> empty .)
    UNEQUAL         reduce using rule 56 (FTYPE -> empty .)
    ;               reduce using rule 56 (FTYPE -> empty .)
    )               reduce using rule 56 (FTYPE -> empty .)
    ,               reduce using rule 56 (FTYPE -> empty .)


state 84

    (57) Call -> ( . RealPara )
    (58) RealPara -> . RealParaTable
    (59) RealPara -> . empty
    (60) RealParaTable -> . Para TRealParaTable
    (64) empty -> .
    (63) Para -> . Expression
    (38) Expression -> . AddExpression
    (39) Expression -> . AddExpression < AddExpression
    (40) Expression -> . AddExpression LESS AddExpression
    (41) Expression -> . AddExpression > AddExpression
    (42) Expression -> . AddExpression GREATER AddExpression
    (43) Expression -> . AddExpression EQUAL AddExpression
    (44) Expression -> . AddExpression UNEQUAL AddExpression
    (45) Expression -> . - Expression
    (46) AddExpression -> . Term
    (47) AddExpression -> . Term + Term
    (48) AddExpression -> . Term - Term
    (49) Term -> . Factor
    (50) Term -> . Factor * Factor
    (51) Term -> . Factor / Factor
    (52) Factor -> . NUMBER
    (53) Factor -> . ( Expression )
    (54) Factor -> . ID FTYPE

    )               reduce using rule 64 (empty -> .)
    -               shift and go to state 57
    NUMBER          shift and go to state 60
    (               shift and go to state 61
    ID              shift and go to state 62

    RealPara                       shift and go to state 99
    RealParaTable                  shift and go to state 100
    empty                          shift and go to state 101
    Para                           shift and go to state 102
    Expression                     shift and go to state 103
    AddExpression                  shift and go to state 56
    Term                           shift and go to state 58
    Factor                         shift and go to state 59

state 85

    (28) AssignSentence -> ID = Expression ; .

    INT             reduce using rule 28 (AssignSentence -> ID = Expression ; .)
    IF              reduce using rule 28 (AssignSentence -> ID = Expression ; .)
    WHILE           reduce using rule 28 (AssignSentence -> ID = Expression ; .)
    RETURN          reduce using rule 28 (AssignSentence -> ID = Expression ; .)
    ID              reduce using rule 28 (AssignSentence -> ID = Expression ; .)
    }               reduce using rule 28 (AssignSentence -> ID = Expression ; .)


state 86

    (34) IfSentence -> IF ( Expression ) . M Block N M ElseSentence
    (32) M -> . empty
    (64) empty -> .

    {               reduce using rule 64 (empty -> .)

    M                              shift and go to state 104
    empty                          shift and go to state 53

state 87

    (31) WhileSentence -> WHILE M ( Expression . ) M Block

    )               shift and go to state 105


state 88

    (39) Expression -> AddExpression < AddExpression .

    ;               reduce using rule 39 (Expression -> AddExpression < AddExpression .)
    )               reduce using rule 39 (Expression -> AddExpression < AddExpression .)
    ,               reduce using rule 39 (Expression -> AddExpression < AddExpression .)


state 89

    (40) Expression -> AddExpression LESS AddExpression .

    ;               reduce using rule 40 (Expression -> AddExpression LESS AddExpression .)
    )               reduce using rule 40 (Expression -> AddExpression LESS AddExpression .)
    ,               reduce using rule 40 (Expression -> AddExpression LESS AddExpression .)


state 90

    (41) Expression -> AddExpression > AddExpression .

    ;               reduce using rule 41 (Expression -> AddExpression > AddExpression .)
    )               reduce using rule 41 (Expression -> AddExpression > AddExpression .)
    ,               reduce using rule 41 (Expression -> AddExpression > AddExpression .)


state 91

    (42) Expression -> AddExpression GREATER AddExpression .

    ;               reduce using rule 42 (Expression -> AddExpression GREATER AddExpression .)
    )               reduce using rule 42 (Expression -> AddExpression GREATER AddExpression .)
    ,               reduce using rule 42 (Expression -> AddExpression GREATER AddExpression .)


state 92

    (43) Expression -> AddExpression EQUAL AddExpression .

    ;               reduce using rule 43 (Expression -> AddExpression EQUAL AddExpression .)
    )               reduce using rule 43 (Expression -> AddExpression EQUAL AddExpression .)
    ,               reduce using rule 43 (Expression -> AddExpression EQUAL AddExpression .)


state 93

    (44) Expression -> AddExpression UNEQUAL AddExpression .

    ;               reduce using rule 44 (Expression -> AddExpression UNEQUAL AddExpression .)
    )               reduce using rule 44 (Expression -> AddExpression UNEQUAL AddExpression .)
    ,               reduce using rule 44 (Expression -> AddExpression UNEQUAL AddExpression .)


state 94

    (47) AddExpression -> Term + Term .

    <               reduce using rule 47 (AddExpression -> Term + Term .)
    LESS            reduce using rule 47 (AddExpression -> Term + Term .)
    >               reduce using rule 47 (AddExpression -> Term + Term .)
    GREATER         reduce using rule 47 (AddExpression -> Term + Term .)
    EQUAL           reduce using rule 47 (AddExpression -> Term + Term .)
    UNEQUAL         reduce using rule 47 (AddExpression -> Term + Term .)
    ;               reduce using rule 47 (AddExpression -> Term + Term .)
    )               reduce using rule 47 (AddExpression -> Term + Term .)
    ,               reduce using rule 47 (AddExpression -> Term + Term .)


state 95

    (48) AddExpression -> Term - Term .

    <               reduce using rule 48 (AddExpression -> Term - Term .)
    LESS            reduce using rule 48 (AddExpression -> Term - Term .)
    >               reduce using rule 48 (AddExpression -> Term - Term .)
    GREATER         reduce using rule 48 (AddExpression -> Term - Term .)
    EQUAL           reduce using rule 48 (AddExpression -> Term - Term .)
    UNEQUAL         reduce using rule 48 (AddExpression -> Term - Term .)
    ;               reduce using rule 48 (AddExpression -> Term - Term .)
    )               reduce using rule 48 (AddExpression -> Term - Term .)
    ,               reduce using rule 48 (AddExpression -> Term - Term .)


state 96

    (50) Term -> Factor * Factor .

    +               reduce using rule 50 (Term -> Factor * Factor .)
    -               reduce using rule 50 (Term -> Factor * Factor .)
    <               reduce using rule 50 (Term -> Factor * Factor .)
    LESS            reduce using rule 50 (Term -> Factor * Factor .)
    >               reduce using rule 50 (Term -> Factor * Factor .)
    GREATER         reduce using rule 50 (Term -> Factor * Factor .)
    EQUAL           reduce using rule 50 (Term -> Factor * Factor .)
    UNEQUAL         reduce using rule 50 (Term -> Factor * Factor .)
    ;               reduce using rule 50 (Term -> Factor * Factor .)
    )               reduce using rule 50 (Term -> Factor * Factor .)
    ,               reduce using rule 50 (Term -> Factor * Factor .)


state 97

    (51) Term -> Factor / Factor .

    +               reduce using rule 51 (Term -> Factor / Factor .)
    -               reduce using rule 51 (Term -> Factor / Factor .)
    <               reduce using rule 51 (Term -> Factor / Factor .)
    LESS            reduce using rule 51 (Term -> Factor / Factor .)
    >               reduce using rule 51 (Term -> Factor / Factor .)
    GREATER         reduce using rule 51 (Term -> Factor / Factor .)
    EQUAL           reduce using rule 51 (Term -> Factor / Factor .)
    UNEQUAL         reduce using rule 51 (Term -> Factor / Factor .)
    ;               reduce using rule 51 (Term -> Factor / Factor .)
    )               reduce using rule 51 (Term -> Factor / Factor .)
    ,               reduce using rule 51 (Term -> Factor / Factor .)


state 98

    (53) Factor -> ( Expression ) .

    *               reduce using rule 53 (Factor -> ( Expression ) .)
    /               reduce using rule 53 (Factor -> ( Expression ) .)
    +               reduce using rule 53 (Factor -> ( Expression ) .)
    -               reduce using rule 53 (Factor -> ( Expression ) .)
    <               reduce using rule 53 (Factor -> ( Expression ) .)
    LESS            reduce using rule 53 (Factor -> ( Expression ) .)
    >               reduce using rule 53 (Factor -> ( Expression ) .)
    GREATER         reduce using rule 53 (Factor -> ( Expression ) .)
    EQUAL           reduce using rule 53 (Factor -> ( Expression ) .)
    UNEQUAL         reduce using rule 53 (Factor -> ( Expression ) .)
    ;               reduce using rule 53 (Factor -> ( Expression ) .)
    )               reduce using rule 53 (Factor -> ( Expression ) .)
    ,               reduce using rule 53 (Factor -> ( Expression ) .)


state 99

    (57) Call -> ( RealPara . )

    )               shift and go to state 106


state 100

    (58) RealPara -> RealParaTable .

    )               reduce using rule 58 (RealPara -> RealParaTable .)


state 101

    (59) RealPara -> empty .

    )               reduce using rule 59 (RealPara -> empty .)


state 102

    (60) RealParaTable -> Para . TRealParaTable
    (61) TRealParaTable -> . , Para TRealParaTable
    (62) TRealParaTable -> . empty
    (64) empty -> .

    ,               shift and go to state 108
    )               reduce using rule 64 (empty -> .)

    TRealParaTable                 shift and go to state 107
    empty                          shift and go to state 109

state 103

    (63) Para -> Expression .

    ,               reduce using rule 63 (Para -> Expression .)
    )               reduce using rule 63 (Para -> Expression .)


state 104

    (34) IfSentence -> IF ( Expression ) M . Block N M ElseSentence
    (16) Block -> . { LangStr TLangStr }

    {               shift and go to state 28

    Block                          shift and go to state 110

state 105

    (31) WhileSentence -> WHILE M ( Expression ) . M Block
    (32) M -> . empty
    (64) empty -> .

    {               reduce using rule 64 (empty -> .)

    M                              shift and go to state 111
    empty                          shift and go to state 53

state 106

    (57) Call -> ( RealPara ) .

    *               reduce using rule 57 (Call -> ( RealPara ) .)
    /               reduce using rule 57 (Call -> ( RealPara ) .)
    +               reduce using rule 57 (Call -> ( RealPara ) .)
    -               reduce using rule 57 (Call -> ( RealPara ) .)
    <               reduce using rule 57 (Call -> ( RealPara ) .)
    LESS            reduce using rule 57 (Call -> ( RealPara ) .)
    >               reduce using rule 57 (Call -> ( RealPara ) .)
    GREATER         reduce using rule 57 (Call -> ( RealPara ) .)
    EQUAL           reduce using rule 57 (Call -> ( RealPara ) .)
    UNEQUAL         reduce using rule 57 (Call -> ( RealPara ) .)
    ;               reduce using rule 57 (Call -> ( RealPara ) .)
    )               reduce using rule 57 (Call -> ( RealPara ) .)
    ,               reduce using rule 57 (Call -> ( RealPara ) .)


state 107

    (60) RealParaTable -> Para TRealParaTable .

    )               reduce using rule 60 (RealParaTable -> Para TRealParaTable .)


state 108

    (61) TRealParaTable -> , . Para TRealParaTable
    (63) Para -> . Expression
    (38) Expression -> . AddExpression
    (39) Expression -> . AddExpression < AddExpression
    (40) Expression -> . AddExpression LESS AddExpression
    (41) Expression -> . AddExpression > AddExpression
    (42) Expression -> . AddExpression GREATER AddExpression
    (43) Expression -> . AddExpression EQUAL AddExpression
    (44) Expression -> . AddExpression UNEQUAL AddExpression
    (45) Expression -> . - Expression
    (46) AddExpression -> . Term
    (47) AddExpression -> . Term + Term
    (48) AddExpression -> . Term - Term
    (49) Term -> . Factor
    (50) Term -> . Factor * Factor
    (51) Term -> . Factor / Factor
    (52) Factor -> . NUMBER
    (53) Factor -> . ( Expression )
    (54) Factor -> . ID FTYPE

    -               shift and go to state 57
    NUMBER          shift and go to state 60
    (               shift and go to state 61
    ID              shift and go to state 62

    Para                           shift and go to state 112
    Expression                     shift and go to state 103
    AddExpression                  shift and go to state 56
    Term                           shift and go to state 58
    Factor                         shift and go to state 59

state 109

    (62) TRealParaTable -> empty .

    )               reduce using rule 62 (TRealParaTable -> empty .)


state 110

    (34) IfSentence -> IF ( Expression ) M Block . N M ElseSentence
    (35) N -> . empty
    (64) empty -> .

    ELSE            reduce using rule 64 (empty -> .)
    INT             reduce using rule 64 (empty -> .)
    IF              reduce using rule 64 (empty -> .)
    WHILE           reduce using rule 64 (empty -> .)
    RETURN          reduce using rule 64 (empty -> .)
    ID              reduce using rule 64 (empty -> .)
    }               reduce using rule 64 (empty -> .)

    N                              shift and go to state 113
    empty                          shift and go to state 114

state 111

    (31) WhileSentence -> WHILE M ( Expression ) M . Block
    (16) Block -> . { LangStr TLangStr }

    {               shift and go to state 28

    Block                          shift and go to state 115

state 112

    (61) TRealParaTable -> , Para . TRealParaTable
    (61) TRealParaTable -> . , Para TRealParaTable
    (62) TRealParaTable -> . empty
    (64) empty -> .

    ,               shift and go to state 108
    )               reduce using rule 64 (empty -> .)

    TRealParaTable                 shift and go to state 116
    empty                          shift and go to state 109

state 113

    (34) IfSentence -> IF ( Expression ) M Block N . M ElseSentence
    (32) M -> . empty
    (64) empty -> .

    ELSE            reduce using rule 64 (empty -> .)
    INT             reduce using rule 64 (empty -> .)
    IF              reduce using rule 64 (empty -> .)
    WHILE           reduce using rule 64 (empty -> .)
    RETURN          reduce using rule 64 (empty -> .)
    ID              reduce using rule 64 (empty -> .)
    }               reduce using rule 64 (empty -> .)

    M                              shift and go to state 117
    empty                          shift and go to state 53

state 114

    (35) N -> empty .

    ELSE            reduce using rule 35 (N -> empty .)
    INT             reduce using rule 35 (N -> empty .)
    IF              reduce using rule 35 (N -> empty .)
    WHILE           reduce using rule 35 (N -> empty .)
    RETURN          reduce using rule 35 (N -> empty .)
    ID              reduce using rule 35 (N -> empty .)
    }               reduce using rule 35 (N -> empty .)


state 115

    (31) WhileSentence -> WHILE M ( Expression ) M Block .

    INT             reduce using rule 31 (WhileSentence -> WHILE M ( Expression ) M Block .)
    IF              reduce using rule 31 (WhileSentence -> WHILE M ( Expression ) M Block .)
    WHILE           reduce using rule 31 (WhileSentence -> WHILE M ( Expression ) M Block .)
    RETURN          reduce using rule 31 (WhileSentence -> WHILE M ( Expression ) M Block .)
    ID              reduce using rule 31 (WhileSentence -> WHILE M ( Expression ) M Block .)
    }               reduce using rule 31 (WhileSentence -> WHILE M ( Expression ) M Block .)


state 116

    (61) TRealParaTable -> , Para TRealParaTable .

    )               reduce using rule 61 (TRealParaTable -> , Para TRealParaTable .)


state 117

    (34) IfSentence -> IF ( Expression ) M Block N M . ElseSentence
    (36) ElseSentence -> . empty
    (37) ElseSentence -> . ELSE Block
    (64) empty -> .

    ELSE            shift and go to state 120
    INT             reduce using rule 64 (empty -> .)
    IF              reduce using rule 64 (empty -> .)
    WHILE           reduce using rule 64 (empty -> .)
    RETURN          reduce using rule 64 (empty -> .)
    ID              reduce using rule 64 (empty -> .)
    }               reduce using rule 64 (empty -> .)

    ElseSentence                   shift and go to state 118
    empty                          shift and go to state 119

state 118

    (34) IfSentence -> IF ( Expression ) M Block N M ElseSentence .

    INT             reduce using rule 34 (IfSentence -> IF ( Expression ) M Block N M ElseSentence .)
    IF              reduce using rule 34 (IfSentence -> IF ( Expression ) M Block N M ElseSentence .)
    WHILE           reduce using rule 34 (IfSentence -> IF ( Expression ) M Block N M ElseSentence .)
    RETURN          reduce using rule 34 (IfSentence -> IF ( Expression ) M Block N M ElseSentence .)
    ID              reduce using rule 34 (IfSentence -> IF ( Expression ) M Block N M ElseSentence .)
    }               reduce using rule 34 (IfSentence -> IF ( Expression ) M Block N M ElseSentence .)


state 119

    (36) ElseSentence -> empty .

    INT             reduce using rule 36 (ElseSentence -> empty .)
    IF              reduce using rule 36 (ElseSentence -> empty .)
    WHILE           reduce using rule 36 (ElseSentence -> empty .)
    RETURN          reduce using rule 36 (ElseSentence -> empty .)
    ID              reduce using rule 36 (ElseSentence -> empty .)
    }               reduce using rule 36 (ElseSentence -> empty .)


state 120

    (37) ElseSentence -> ELSE . Block
    (16) Block -> . { LangStr TLangStr }

    {               shift and go to state 28

    Block                          shift and go to state 121

state 121

    (37) ElseSentence -> ELSE Block .

    INT             reduce using rule 37 (ElseSentence -> ELSE Block .)
    IF              reduce using rule 37 (ElseSentence -> ELSE Block .)
    WHILE           reduce using rule 37 (ElseSentence -> ELSE Block .)
    RETURN          reduce using rule 37 (ElseSentence -> ELSE Block .)
    ID              reduce using rule 37 (ElseSentence -> ELSE Block .)
    }               reduce using rule 37 (ElseSentence -> ELSE Block .)

